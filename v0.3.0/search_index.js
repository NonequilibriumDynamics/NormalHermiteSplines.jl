var documenterSearchIndex = {"docs":
[{"location":"Public-API/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"Public-API/#API-Summary","page":"Public API","title":"API Summary","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"Function Description\nprepare Prepare the spline by constructing and factoring a Gram matrix of the interpolation problem.\nconstruct Construct the spline by calculating its coefficients.\ninterpolate Prepare and construct the spline.\nevaluate Evaluate the spline value at the required locations\nevaluate_one Evaluate the spline value at the required location\nevaluate_gradient Evaluate gradient of the spline at the required location.\nevaluate_derivative Evaluate the 1D spline derivative at the required location.\nassess_interpolation Assess interpolation result.\nget_cond Get an estimation of the Gram matrix condition number.\nget_epsilon Get the 'scaling parameter' of Bessel Potential space the normal spline was built in.\nestimate_epsilon Get an estimation of the 'scaling parameter' of Bessel Potential space the spline being built in.","category":"page"},{"location":"Public-API/#Functions","page":"Public API","title":"Functions","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"prepare\r\nconstruct\r\ninterpolate\r\nevaluate\r\nevaluate_one\r\nevaluate_gradient\r\nevaluate_derivative\r\nassess_interpolation\r\nget_cond\r\nget_epsilon\r\nestimate_epsilon","category":"page"},{"location":"Public-API/#NormalHermiteSplines.prepare","page":"Public API","title":"NormalHermiteSplines.prepare","text":"prepare(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes. It means that each column in the matrix defines one node.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare the spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space and          n_1 is the number of function value nodes.           It means that each column in the matrix defines one node.\nd_nodes: The function directional derivatives nodes.            This should be an n×n_2 matrix, where n is dimension of the sampled space and            n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.       This should be an n×n_2 matrix, where n is dimension of the sampled space and       n_2 is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare the 1D spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\nprepare(nodes::Vector{T}, d_nodes::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare the 1D normal spline by constructing and factoring a Gram matrix of the interpolation problem. Initialize the NormalSpline object.\n\nArguments\n\nnodes: The function value nodes.\nd_nodes: The function derivatives nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the partly initialized NormalSpline object that must be passed to construct function         in order to complete the spline initialization.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.construct","page":"Public API","title":"NormalHermiteSplines.construct","text":"construct(spline::NormalSpline{T, RK}, values::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function         to interpolate the data to required points.\n\n\n\n\n\nconstruct(spline::NormalSpline{T, RK}, values::Vector{T}, d_values::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nConstruct the spline by calculating its coefficients and completely initializing the NormalSpline object.\n\nArguments\n\nspline: the partly initialized NormalSpline object returned by prepare function.\nvalues: function values at nodes nodes.\nd_values: function directional derivative values at d_nodes nodes.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function         to interpolate the data to required points.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.interpolate","page":"Public API","title":"NormalHermiteSplines.interpolate","text":"interpolate(nodes::Matrix{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Matrix{T}, values::Vector{T}, d_nodes::Matrix{T}, es::Matrix{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare and construct the spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at nodes nodes.\nd_nodes: The function directional derivative nodes.           This should be an n×n_2 matrix, where n is dimension of the sampled space and           n_2 is the number of function directional derivative nodes.\nes: Directions of the function directional derivatives.      This should be an n×n_2 matrix, where n is dimension of the sampled space and      n_2 is the number of function directional derivative nodes.      It means that each column in the matrix defines one direction of the function directional derivative.\nd_values: function directional derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Vector{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nPrepare and construct the 1D spline.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nvalues: function values at n_1 interpolation nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H0 if the spline is constructing as a continuous function,             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\ninterpolate(nodes::Vector{T}, values::Vector{T}, d_nodes::Vector{T}, d_values::Vector{T}, kernel::RK = RK_H1()) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nPrepare and construct the 1D spline.\n\nArguments\n\nnodes: The function value nodes.\nvalues: function values at nodes nodes.\nd_nodes: The function derivative nodes.\nd_values: function derivative values at d_nodes nodes.\nkernel: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             RK_H1 if the spline is constructing as a differentiable function,             RK_H2 if the spline is constructing as a twice differentiable function.\n\nReturn: the completely initialized NormalSpline object that can be passed to evaluate function.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate","page":"Public API","title":"NormalHermiteSplines.evaluate","text":"evaluate(spline::NormalSpline{T, RK}, points::Matrix{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline values at the locations defined in points.\n\nArguments\n\nspline: theNormalSplineobject returned byinterpolateorconstruct` function.\npoints: locations at which spline values are evaluating.           This should be an n×m matrix, where n is dimension of the sampled space           and m is the number of locations where spline values are evaluating.           It means that each column in the matrix defines one location.\n\nReturn: Vector{T} of the spline values at the locations defined in points.\n\n\n\n\n\nevaluate(spline::NormalSpline{T, RK}, points::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline values/value at the points locations.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoints: locations at which spline values are evaluating.                      This should be a vector of size m where m is the number of evaluating points.\n\nReturn: spline value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_one","page":"Public API","title":"NormalHermiteSplines.evaluate_one","text":"evaluate_one(spline::NormalSpline{T, RK}, point::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating.          This should be a vector of size n, where n is dimension of the sampled space.\n\nReturn: the spline value at the location defined in point.\n\n\n\n\n\nevaluate_one(spline::NormalSpline{T, RK}, point::T) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nEvaluate the 1D spline value at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline value is evaluating.\n\nReturn: spline value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_gradient","page":"Public API","title":"NormalHermiteSplines.evaluate_gradient","text":"evaluate_gradient(spline::NormalSpline{T, RK}, point::Vector{T}) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nEvaluate gradient of the spline at the location defined in point.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which gradient value is evaluating.          This should be a vector of size n, where n is dimension of the sampled space.\n\nReturn: Vector{T} - gradient of the spline at the location defined in point.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.evaluate_derivative","page":"Public API","title":"NormalHermiteSplines.evaluate_derivative","text":"evaluate_derivative(spline::NormalSpline{T, RK}, point::T) where {T <: AbstractFloat, RK <: ReproducingKernel_1}\n\nEvaluate the 1D spline derivative at the point location.\n\nArguments\n\nspline: the NormalSpline object returned by interpolate or construct function.\npoint: location at which spline derivative is evaluating.\n\nReturn: the spline derivative value at the point location.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.assess_interpolation","page":"Public API","title":"NormalHermiteSplines.assess_interpolation","text":"assess_interpolation(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nAssess the interpolation result by calculating value of the Relative Maximum Absolute Error (RMAE) using data of the function value interpolation nodes.\n\nArguments\n\nspline: the NormalSpline object returned by construct or interpolate function.\n\nReturn: RMSE of interpolation at function value nodes.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.get_cond","page":"Public API","title":"NormalHermiteSplines.get_cond","text":"get_cond(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet an estimation of the Gram matrix condition number. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturn: an estimation of the Gram matrix condition number.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.get_epsilon","page":"Public API","title":"NormalHermiteSplines.get_epsilon","text":"get_epsilon(spline::NormalSpline{T, RK}) where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nGet the 'scaling parameter' of Bessel Potential space the spline was built in.\n\nArguments\n\nspline: the NormalSpline object returned by prepare, construct or interpolate function.\n\nReturn: ε - the 'scaling parameter'.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#NormalHermiteSplines.estimate_epsilon","page":"Public API","title":"NormalHermiteSplines.estimate_epsilon","text":"estimate_epsilon(nodes::Matrix{T}) where T <: AbstractFloat\n\nGet the estimation of the 'scaling parameter' of Bessel Potential space the spline was built in. It should have the same order as result returned by get_epsilon function if all nodes are located in a unit hypercube.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Matrix{T}, d_nodes::Matrix{T}) where T <: AbstractFloat\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline was built in. It should have the same order as result returned by get_epsilon function if all nodes and d_nodes are located in a unit hypercube.\n\nArguments\n\nnodes: The function value nodes.          This should be an n×n_1 matrix, where n is dimension of the sampled space          and n_1 is the number of function value nodes.          It means that each column in the matrix defines one node.\nd_nodes: The function directional derivative nodes.          This should be an n×n_2 matrix, where n is dimension of the sampled space and          n_2 is the number of function directional derivative nodes.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Vector{T}) where T <: AbstractFloat\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline was built in. It should have the same order as result returned by get_epsilon function if all nodes are located in a unit hypercube.\n\nArguments\n\nnodes: The function value nodes.\n\nReturn: estimation of ε.\n\n\n\n\n\nestimate_epsilon(nodes::Vector{T}, d_nodes::Vector{T}) where T <: AbstractFloat\n\nGet an the estimation of the 'scaling parameter' of Bessel Potential space the spline was built in. It should have the same order as result returned by get_epsilon function if all nodes and d_nodes are located in a unit hypercube.\n\nArguments\n\nnodes: The function value nodes.\nd_nodes: The function derivative nodes.\n\nReturn: estimation of ε.\n\n\n\n\n\n","category":"function"},{"location":"Public-API/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"Public-API/#Bessel-Potential-Space-Reproducing-Kernels","page":"Public API","title":"Bessel Potential Space Reproducing Kernels","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"RK_H0\r\nRK_H1\r\nRK_H2","category":"page"},{"location":"Public-API/#NormalHermiteSplines.RK_H0","page":"Public API","title":"NormalHermiteSplines.RK_H0","text":"struct RK_H0{T <: AbstractFloat} <: ReproducingKernel_0\n\nDefine a type of reproducing kernel of Bessel Potential space H^n2 + 12_ε (R^n):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalHermiteSplines.RK_H1","page":"Public API","title":"NormalHermiteSplines.RK_H1","text":"struct RK_H1{T <: AbstractFloat} <: ReproducingKernel_1\n\nDefine a type of reproducing kernel of Bessel Potential space H^n2 + 32_ε (R^n):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (1 + varepsilon xi  - eta)  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalHermiteSplines.RK_H2","page":"Public API","title":"NormalHermiteSplines.RK_H2","text":"struct RK_H2{T <: AbstractFloat} <: ReproducingKernel_2\n\nDefine a type of reproducing kernel of Bessel Potential space H^n2 + 52_ε (R^n):\n\nV(eta  xi varepsilon) = exp (-varepsilon xi - eta)\n             (3 + 3varepsilon xi  - eta + varepsilon ^2 xi - eta ^2 )  \n\nFields\n\nε::T: 'scaling parameter' from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#NormalSpline-structure","page":"Public API","title":"NormalSpline structure","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"NormalSpline","category":"page"},{"location":"Public-API/#NormalHermiteSplines.NormalSpline","page":"Public API","title":"NormalHermiteSplines.NormalSpline","text":"struct NormalSpline{T, RK} <: AbstractSpline where {T <: AbstractFloat, RK <: ReproducingKernel_0}\n\nDefine a structure containing full information of a normal spline\n\nFields\n\n_kernel: a reproducing kernel spline was built with.\n_compression: factor of transforming the original node locations into unit hypercube\n_nodes: transformed function value nodes\n_values: function values at interpolation nodes\n_d_nodes: transformed function directional derivative nodes\n_es: normalized derivative directions\n_d_values: function directional derivative values\n_min_bound: minimal bounds of the original node locations area\n_gram: Gram matrix of the problem\n_chol: Cholesky factorization of the Gram matrix\n_mu: spline coefficients\n_cond: estimation of the Gram matrix condition number\n\n\n\n\n\n","category":"type"},{"location":"Public-API/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"Public-API/","page":"Public API","title":"Public API","text":"Order = [:function, :type]","category":"page"},{"location":"Updating-Cholesky-Factorization/#Algorithms-for-updating-Cholesky-factorization","page":"Updating Cholesky Factorization","title":"Algorithms for updating Cholesky factorization","text":"","category":"section"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"A problem of updating Cholesky factorization was treated in [1], [2] and [3]. Here algorithms taken from these works are described. These algorithms are for computing a factorization tilde A = tilde L tilde L^T where tilde A is a matrix received of the matrix A = L L^T after a row and the symmetric column were added or deleted from A. Let A in R^n times n is a symmetric positive definite matrix. Applying Cholesky method to A yields the factorization A = L L^T where L is a lower triangular matrix with positive diagonal elements. Suppose tilde A is a positive definite matrix created by adding a row and the symmetric  column to A:","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    tilde A = left( beginarraycc\r\n       A  d \r\n       d^T  gamma\r\n      endarray\r\n      right)   qquad d^T  in R^n","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"Then its Cholesky factorization is [2]:","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    tilde L = left( beginarraycc\r\n       L  \r\n       e^T  alpha\r\n      endarray\r\n      right)  ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"where","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"     e = L^-1 d  ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"and","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    alpha = sqrt tau    quad tau = gamma - e^T e quad tau  0","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"If tau le 0 then tilde A is not positive definite.","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"Now assume tilde A is obtained by deleting the r^th row and column from A. Matrix tilde A is the positive definite matrix (as any principal square submatrix of the positive definite matrix). It is shown in [1],[3] how to get tilde L from L in such case. Let us partition A and L along the r^th row and column:","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    A = left( beginarrayccc\r\n          A_11  a_1r  A_12 \r\n          a_1r^T  a_rr  a_2r^T \r\n          A_21  a_2r  A_22\r\n      endarray\r\n     right)   qquad\r\n    L = left( beginarrayccc\r\n   L_11   \r\n   l_1r^T  l_rr   \r\n   L_21  l_2r  L_22\r\n    endarray\r\n     right)  ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"Then tilde A can be written as","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    tilde A = left( beginarraycc\r\n    A_11   A_12 \r\n    A_21   A_22\r\n    endarray\r\n     right)  ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"By deleting the r^th row from L we get the matrix","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    H = left( beginarrayccc\r\n  L_11     \r\n  L_21  l_2r  L_22\r\n    endarray\r\n     right) ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"with the property that H H^T = tilde A. Factor tilde L can be received from H by applying Givens rotations to the matrix elements h_r r+1 h_r+1 r+2 dots  h_n-1 n and deleting the last column of the obtained matrix tilde H:","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    tilde H = H R = left( beginarrayccc\r\n  L_11 \r\n  L_21   tilde L_22  0\r\n    endarray\r\n     right) =  Bigl( tilde L  0 Bigr)  ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"where R=R_0 R_1 dots R_n - 1 - r is the matrix of Givens rotations, L_11 and tilde L_22 - lower triangle matrices, and","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"beginaligned\r\n  tilde L = left( beginarraycc\r\n  L_11    \r\n  L_21   tilde L_22\r\n    endarray  right)    \r\n\r\n tilde H  tilde H^T = H R R^T H^T = H H^T = tilde A   \r\n\r\n  tilde H  tilde H^T = tilde L tilde L^T   quad tilde L tilde L^T = tilde A  \r\nendaligned","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"Orthogonal matrix R_t  (0 le t le n - 1 -r) R_t in R^n times n which defines the Givens rotation annulating (r+t  r+t+1)th element of the H_k R_0 dots R_t-1 matrix is defined as","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"    R_t = left( beginarraycccccc\r\n   1       ldots  0       0       ldots  0 \r\n   vdots  ldots  ldots  ldots  ldots  vdots \r\n   0       ldots  c       s       ldots  0 \r\n   0       ldots  -s      c       ldots  0 \r\n   vdots  ldots  ldots  ldots  ldots  vdots \r\n   0       ldots  0       0       ldots  1\r\n    endarray\r\n     right)  ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"where entries ( r+t  r+t ) and ( r+t+1  r+t+1 ) equal c,  ( r+t  r+t+1 ) entry equals s, and ( r+t+1  r+t ) entry equals -s, here c^2 + s^2 = 1. Let's tilde l_ij^t-1 - coefficients of matrix H_k R_0 dots R_t-1 (tilde l_ij^-1 - coefficients of H_k) and","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"  c = frac tilde l_r+tr+t^t-1 \r\n sqrt (tilde l_r+tr+t^t-1)^2 + (tilde l_r+tr+t+1^t-1)^2    \r\nquad\r\n  s = frac tilde l_r+tr+t+1^t-1 \r\n sqrt (tilde l_r+tr+t^t-1)^2 + (tilde l_r+tr+t+1^t-1)^2    ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"Then matrix H_k R_0 dots R_t will differ from H_k R_0 dots R_t-1 with entries of ( r+t ) и ( r+t+1 ) columns only, thereby","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"beginaligned\r\n  tilde l_ir+t^t = tilde l_ir+t^t-1 = 0     \r\n     tilde l_ir+t+1^t = tilde l_ir+t+1^t-1 = 0  \r\n     qquad qquad qquad     1 le i le r + t  - 1   \r\n\r\n  tilde l_ir+t^t = c tilde l_ir+t^t-1 +  s tilde l_ir+t+1^t-1  \r\n    \r\ntilde l_ir+t+1^t = -s tilde l_ir+t^t-1 +  c tilde l_ir+t+1^t-1 \r\n     quad  r + t le i le n - 1  \r\nendaligned","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"where","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"  tilde l_r+tr+t^t =\r\nsqrt (tilde l_r+tr+t^t-1)^2 + (tilde l_r+tr+t+1^t-1)^2   \r\nqquad\r\n  tilde l_r+tr+t+1^t = 0     ","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"Also, coefficient tilde l_r+tr+t^t is a nonnegative one. In order to avoid unnecessary overflow or underflow during computation of c and s, it was recommended [3] to calculate value of the square root w = sqrtx^2 + y^2 as folows:","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"beginaligned\r\n  v = max  x  y    qquad u = min  x  y   \r\n\r\n w = begincases v sqrt 1 + left( fracuv right)^2   \r\n                    quad v ne 0 cr cr\r\n              0   quad v = 0 cr\r\n      endcases  \r\n\r\nendaligned","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"Applying the this technique to Cholesky factorization allows significally reduce the complexity of calculations. So, in case of adding a row and the symmetric column to the original matrix it will be necessary to carry out about n^2 flops instead of about frac (n + 1) ^ 3 3 flops for the direct calculation of the new Cholesky factor. In the case of deleting a row and the symmetric column from the original matrix, the new Cholesky factor can be obtained with about 3(n - r)^2 flops (the worst case requires about 3 (n - 1) ^ 2 operations) instead of about frac (n - 1) ^ 3 3 flops required for its direct calculation.","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"References","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"[1] T. F. Coleman, L. A. Hulbert, A direct active set  algorithm for large sparse quadratic programs with simple bounds, Mathematical Programming, 45, 1989.","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"[2] J. A. George, J. W-H. Liu, Computer Solution of Large Sparse Positive Definite Systems, Prentice-Hall, 1981.","category":"page"},{"location":"Updating-Cholesky-Factorization/","page":"Updating Cholesky Factorization","title":"Updating Cholesky Factorization","text":"[3] C. L. Lawson, R. J. Hanson, Solving least squares problems, SIAM, 1995.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"﻿","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/#Reproducing-Kernel-of-Bessel-Potential-space","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"","category":"section"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"The standard definition of Bessel potential space H^s can be found in ([1], [2], [6], [11], [12]). Here the normal splines will be constructed in the Bessel potential space H^s_varepsilon defined as:","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi  in L_2 (R^n) right  quad\r\n  varepsilon gt 0    s gt fracn2 ","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"where S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. The parameter varepsilon introduced here may be considered as a \"scaling parameter\". It allows to control approximation properties of the normal spline which usually are getting better with smaller values of varepsilon, also it may be used to reduce the ill-conditioness of the related computational problem (in traditional theory varepsilon = 1).","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Theoretical properties of spaces H^s_varepsilon at varepsilon gt 0 are identical — they are Hilbert spaces with inner product","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"langle varphi  psi rangle _H^s_varepsilon =\r\nint ( varepsilon ^2  +  xi ^2 )^s\r\nmathcal F varphi  overlinemathcal F psi    d xi","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"and  norm","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":" varphi _ H^s_varepsilon = left( langle varphi  varphi rangle _H^s_varepsilon right)^12 =\r\n (  varepsilon ^2 +  xi ^2 )^s2 mathcal F varphi  _L_2  ","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"It is easy to see that all  varphi _H^s_varepsilon norms are equivalent. It means that space H^s_varepsilon (R^n) is equivalent to H^s (R^n) =  H^s_1 (R^n).","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Let's describe the Hölder spaces C_b^t(R^n) t gt 0 ([9], [2]).","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Definition 1. We denote the space","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"   S(R^n) = left f  f in C^infty (R^n)   sup_x in R^n  x^alpha D^beta f(x)   lt infty  forall alpha beta in mathbbN^n  right","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"as Schwartz space (or space of complex-valued rapidly decreasing infinitely differentiable functions defined on R^n) ([6], [7]).","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Below is a definition of Hölder space C^t_b(R^n) [9]:","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Definition 2. If 0 lt t = t + t t is non-negative integer, 0 lt t lt 1, then C^t_b(R^n) denotes the completion of S(R^n) in the norm","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"beginaligned\r\n   C^t_b (R^n) = left f  f in C^t_b (R^n)    f  _C^t_b  lt infty right  \r\n\r\n   f  _C^t_b =  f  _C_b^t  + \r\n\r\nsum _alpha  = t sup _x ne y frac  D^alpha  f(x)  - D^alpha  f(y)     x - y ^t   \r\n\r\n   f  _C_b^t = sup _x in R^n  D^alpha f(x)   forall alpha   alpha  le t\r\nendaligned","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Space C^t_b (R^n) consists of all functions having bounded continuous derivatives up to order t. It is easy to see that C_b^t(R^n) is Banach space [9].","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Connection of Bessel potential spaces H^s(R^n) with the spaces C_b^t(R^n) is expressed in Embedding theorem ([9], [2]).","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Embedding Theorem: If s = n2+t, where t non-integer, t gt 0, then space H^s(R^n) is continuously embedded in C_b^t(R^n).","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Particularly from this theorem follows that if f in H^n2 + 12_varepsilon (R^n), corrected if necessary on a set of Lebesgue measure zero, then it is uniformly continuous and bounded. Further if f in H^n2 + 12 + r_varepsilon (R^n), r — integer non-negative number, then it can be treated as f in C^r (R^n), where C^r (R^n) is a class of functions with r continuous derivatives.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"It can be shown ([3], [11], [8], [4], [5]) that function ","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"beginaligned\r\n  V_s ( eta  x varepsilon ) = c_V (nsvarepsilon) (varepsilon eta - x  )^s - fracn2\r\n\r\n          K_s - fracn2 (varepsilon eta - x  )      \r\n\r\n  c_V (nsvarepsilon) = fracvarepsilon ^n-2s  2^s-1 (2 pi )^n2 Gamma (s)   eta in R^n   x in R^n  varepsilon gt 0   s gt fracn2\r\nendaligned","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"is a reproducing kernel of H^s_varepsilon (R^n) space. Here K_gamma is modified Bessel function of the second kind [10]. The exact value of c_V (nsvarepsilon) is not important here and will be set to sqrtfrac2pi for ease of further calculations. ","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"This reproducing kernel is known as Matérn kernel [4,13].","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"The kernel K_gamma becomes especially simple when gamma  is half-integer. ","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"\r\n gamma =  r  + frac12   (r = 0 1 dots )","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"In this case it is expressed via elementary functions (see [10]):","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"beginaligned\r\nK_r+12(t) =\r\nsqrtfracpi 2t t^r+1 left (\r\n- frac1t fracddt right )^r+1 exp (-t)  \r\n\r\nK_r+12(t) =\r\nsqrtfracpi 2t exp (-t) sum_k=0^r\r\nfrac(r+k)k (r-k) (2t)^k  \r\n  (r = 0 1 dots )   \r\nendaligned","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"Let s_r =  r + fracn2 + frac12   r = 0 1 dots, then H^s_r_varepsilon(R^n) is continuously embedded in C_b^r(R^n) and its reproducing kernel with accuracy to constant multiplier can be presented as follows","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"beginaligned\r\nV_r + fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x ) \r\nsum_k=0^r frac(r+k)2^k k (r-k) (varepsilon eta - x )^r-k  \r\n\r\n  (r = 0 1 dots )   \r\nendaligned","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"In particular we have:","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"beginaligned\r\n V_fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x )  \r\n\r\n V_1 + fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x )\r\n(1 + varepsilon eta - x )  \r\n\r\n V_2 + fracn2 + frac12(eta  x varepsilon) = exp (-varepsilon eta - x )\r\n(3 + 3varepsilon eta - x  + varepsilon ^2 eta - x  ^2 )  \r\nendaligned","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"References","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[1] D. Adams, L. Hedberg, Function spaces and potential theory. Berlin, Springer, 1996.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[2] M. Agranovich, Sobolev Spaces, Their Generalizations and Elliptic Problems in Smooth and Lipschitz Domains, Springer, Switzerland, 2015.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[3] N. Aronszajn, K. Smith, Theory of bessel potentials I, Ann.Inst.Fourier, 11, 1961.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[4] G. Fasshauer, Green’s Functions: Taking Another Look at Kernel Approximation, Radial Basis Functions, and Splines. In: Neamtu M., Schumaker L. (eds) Approximation Theory XIII: San Antonio 2010. Springer Proceedings in Mathematics, vol 13. Springer, New York, 2012.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[5] I. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[6] S. Nikol'skiĭ, Approximation of functions of several variables and imbedding theorems, Grundl. Math. Wissensch., 205, Springer-Verlag, New York, 1975.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[7] M. Reed, B. Simon, Methods of Modern Mathematical Physics, I: Functional Analysis, Academic Press, 1972.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[8] R. Schaback, Kernel-based Meshless Methods, Lecture Notes, Goettingen, 2011.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[9] H. Triebel, Interpolation. Function Spaces. Differential Operators, North-Holland, Amsterdam, 1978.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[10] G. Watson, A Treatise on the Theory of Bessel Functions ( 2nd.ed.), Cambridge University Press, 1966.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[11] H. Wendland, Scattered Data Approximation. Cambridge University Press, 2005.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[12] J. Lions, E. Magenes, Problemes Aux Limites Non-Homogenes et Applications Vol. 1, Dunod, Paris, 1968.","category":"page"},{"location":"Reproducing-Kernel-of-Bessel-Potential-space/","page":"Reproducing Kernel of Bessel Potential space","title":"Reproducing Kernel of Bessel Potential space","text":"[13] G. Fasshauer, M. McCourt, Kernel-Based Approximation Methods Using Matlab, World Scientific, Singapore, 2015.","category":"page"},{"location":"Relation-to-Polyharmonic-Splines/#Relation-to-Polyharmonic-Splines","page":"Relation to Polyharmonic Splines","title":"Relation to Polyharmonic Splines","text":"","category":"section"},{"location":"Tests-with-real-data/#Tests-with-real-data","page":"Tests with real data","title":"Tests with real data","text":"","category":"section"},{"location":"Tests-with-real-data/#.-Big-Sur-Bathymetric-data","page":"Tests with real data","title":"1. Big Sur Bathymetric data","text":"","category":"section"},{"location":"Tests-with-real-data/","page":"Tests with real data","title":"Tests with real data","text":"..... .....","category":"page"},{"location":"Tests-with-real-data/#.-Maunga-Whau-Volcano-data","page":"Tests with real data","title":"2. Maunga Whau Volcano data","text":"","category":"section"},{"location":"Tests-with-real-data/","page":"Tests with real data","title":"Tests with real data","text":"..... ..... Cavoretto, Roberto & De Rossi, Alessandra & Mukhametzhanov, Marat & Sergeyev, Yaroslav. (2019) On the search of the shape parameter in radial basis functions using univariate global optimization methods. Journal of Global Optimization. 10.1007/s10898-019-00853-3.","category":"page"},{"location":"Tests-with-real-data/#.-Jacksboro-Fault-data","page":"Tests with real data","title":"3. Jacksboro Fault data","text":"","category":"section"},{"location":"Tests-with-real-data/","page":"Tests with real data","title":"Tests with real data","text":"..... .....","category":"page"},{"location":"Tests-with-real-data/#.-Baja-Bathymetry-data","page":"Tests with real data","title":"4. Baja Bathymetry data","text":"","category":"section"},{"location":"Tests-with-real-data/","page":"Tests with real data","title":"Tests with real data","text":"..... .....","category":"page"},{"location":"Tests-with-real-data/#.-Kauai-island-data","page":"Tests with real data","title":"5. Kauai island data","text":"","category":"section"},{"location":"Tests-with-real-data/","page":"Tests with real data","title":"Tests with real data","text":"..... .....","category":"page"},{"location":"Tests-with-real-data/#.-Earthquakes-in-Fiji-data","page":"Tests with real data","title":"6. Earthquakes in Fiji data","text":"","category":"section"},{"location":"Tests-with-real-data/","page":"Tests with real data","title":"Tests with real data","text":"..... .....","category":"page"},{"location":"Usage/#Example-Usage","page":"Example Usage","title":"Example Usage","text":"","category":"section"},{"location":"Usage/#D-interpolation-case","page":"Example Usage","title":"1D interpolation case","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Let's interpolate function f(x)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"f(x) =\r\n    begincases\r\n       0     1 le x lt 6 \r\n       1     6 le x le 10 \r\n       -x5 + 3     6 le x le 15 \r\n       0     15 le x le 20 \r\n    endcases","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"by values of the function in nodes 1 2 3  20 (case A) and by values of the function and values of its first derivatives in the same nodes (case B).","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"DocTestSetup = quote\r\n    using Random\r\n    using NormalHermiteSplines\r\nend","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end\r\n\r\n    # Build a differentiable spline by values of function in nodes\r\n    # (a spline built with RK_H0 kernel is a continuous function,\r\n    #  a spline built with RK_H1 kernel is a continuously differentiable function,\r\n    #  a spline built with RK_H2 kernel is a twice continuously differentiable function).\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = prepare(x, RK_H1())\r\n    \r\n    # An estimation of the Gram matrix condition number\r\n    cond = get_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # A value of the 'scaling parameter' of Bessel Potential space\r\n    # the normal spline was built in.\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    spline = construct(spline, u)\r\n\r\n    p = collect(1.0:0.2:20)        # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                    # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 2A)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline derivatives at the same points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Construct spline by different function values in nodes and evaluate new spline at the same evaluation points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    u2 = 2.0 .* u\r\n    spline = construct(spline, u2)\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using NormalHermiteSplines\r\n\r\n    x = collect(1.0:1.0:20)       # function nodes\r\n    u = x.*0.0                    # function values in nodes\r\n    for i in 6:10\r\n        u[i] = 1.0\r\n    end\r\n    for i in 11:14\r\n        u[i] = -0.2 * i + 3.0\r\n    end\r\n\r\n    s = x                         # function first derivative nodes\r\n    v = x.*0.0                    # function first derivative values\r\n    for i in 11:14\r\n        v[i] = -0.2\r\n    end\r\n\r\n    # Build a differentiable spline by values of function,\r\n    # and values of its first derivatives in nodes\r\n    # (a spline built with RK_H0 kernel is a continuous function,\r\n    #  a spline built with RK_H1 kernel is a continuously differentiable function,\r\n    #  a spline built with RK_H2 kernel is a twice continuously differentiable function).\r\n    # Here value of the 'scaling parameter' ε is estimated in the interpolate procedure.\r\n    spline = interpolate(x, u, s, v, RK_H1())\r\n\r\n    p = collect(1.0:0.2:20)      # evaluation points\r\n    σ = evaluate(spline, p)\r\n    σ = nothing                    # hide","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 1B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"(Image: Example 2B)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline at some points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [3.1, 8.1, 12.1, 18.1]\r\n    σ = evaluate(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Evaluate the spline derivatives at the same points:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    dσ = similar(p)\r\n    for i=1:length(p)\r\n        dσ[i] = evaluate_derivative(spline, p[i])\r\n    end\r\n    dσ","category":"page"},{"location":"Usage/#D-interpolation-case-2","page":"Example Usage","title":"2D interpolation case","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Let's interpolate function phi (xy)  = frac23cos(10x)sin(10y) + frac13sin(10xy) defined on unit square Omega = 01^2.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-cf-32.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-t-32.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-grid-32,3.png\" width=\"197\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We built a spline using function phi values sampled on set of 200 pseudo-random nodes uniformly distributed on Omega (case A).","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Spline plot                                                                        Approximation error plots","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/s-cf-32,32,3,1,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-cf-32,32,3,1,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-s-32,32,3,1,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"and ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"using function phi values sampled on set of 200 pseudo-random nodes uniformly distributed on Omega and 80 function phi gradient values defined at nodes located on the border of domain Omega (case B):","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/m-grid-33,3.png\" width=\"197\"/> ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"here red dots represent the function phi gradient value nodes. ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Spline plot                                                                         Approximation error plots","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/s-cf-33,33,3,1,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-cf-33,33,3,1,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"<img src=\"../images/2d-usage/delta-s-33,33,3,1,0.0,-.png\" width=\"256\"/>","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Following is the code example for case A:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using Random\r\n    using NormalHermiteSplines\r\n\r\n    # generating 200 uniform random nodes\r\n    m = 200\r\n    nodes = Matrix{Float64}(undef, 2, m)\r\n    rng = MersenneTwister(0);\r\n    rnd = rand(rng, Float64, (2, m))\r\n    for i = 1:m\r\n        nodes[1, i] = rnd[1, i]\r\n        nodes[2, i] = rnd[2, i]\r\n    end\r\n\r\n    u = Vector{Float64}(undef, m)     # function values at nodes\r\n    for i = 1:m\r\n        x = nodes[1,i]\r\n        y = nodes[2,i]\r\n        u[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    # creating the uniform Cartesian grid of size 51x51 on [0, 1]x[0, 1]\r\n    t = 50\r\n    x = collect(range(0.0, 1.0; step = 1.0/t))\r\n    y = collect(range(0.0, 1.0; step = 1.0/t))\r\n    t1 = t + 1\r\n\r\n    grid = Matrix{Float64}(undef, 2, t1^2)\r\n    for i = 1:t1\r\n        for j = 1:t1\r\n            r = (i - 1) * t1 + j\r\n            grid[1, r] = x[i]\r\n            grid[2, r] = y[j]\r\n        end\r\n    end\r\n\r\n    # Here spline is being constructed with RK_H1 kernel,\r\n    # the value of the 'scaling parameter' ε is estimated\r\n    # in the interpolate procedure.\r\n    rk = RK_H1()\r\n    #\r\n    spline = interpolate(nodes, u, rk)\r\n    cond = get_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # A value of the 'scaling parameter' of Bessel Potential space\r\n    # the normal spline was built in.\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"\r\n    σ = evaluate(spline, grid)\r\n    σ = nothing","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of function phi at evaluation point p = 05 05","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [0.5; 0.5]\r\n    x = p[1]\r\n    y = p[2]\r\n    f = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of spline at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate_one(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Difference of function phi and spline values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff = f - σ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of function phi at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    g1 = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n    g2 = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0 \r\n    f_grad = [g1; g2]","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of spline at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ_grad = evaluate_gradient(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Norm of difference of function phi and spline gradient values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff_grad = sqrt(sum((f_grad .- σ_grad).^2))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Corresponding code example for case B:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    using Random\r\n    using NormalHermiteSplines\r\n\r\n    function get_2D_border_nodes(m::Int)\r\n        mat0 = [0.0 0.0; 0.0 1.0; 1.0 0.0; 1.0 1.0]'\r\n        if m < 1\r\n            return mat0\r\n        end\r\n        m1 = m + 1\r\n        p = collect(range(1.0/m1, (1.0 - 1.0/m1); step = 1.0/m1))\r\n        ms = m * 4\r\n        mat = Matrix{Float64}(undef, 2, ms)\r\n        for i = 1:m\r\n            mat[1,i] = 0.0\r\n            mat[2,i] = p[i]\r\n        end\r\n        for i = (m+1):(2*m)\r\n            mat[1,i] = 1.0\r\n            mat[2,i] = p[i-m]\r\n        end\r\n        for i = (2*m+1):(3*m)\r\n            mat[1,i] = p[i-2*m]\r\n            mat[2,i] = 0.0\r\n        end\r\n        for i = (3*m+1):(4*m)\r\n            mat[1,i] = p[i-3*m]\r\n            mat[2,i] = 1.0\r\n        end\r\n        w = hcat(mat0, mat)\r\n        return w\r\n    end\r\n\r\n    # generating 200 uniform random nodes\r\n    m = 200\r\n    nodes = Matrix{Float64}(undef, 2, m)\r\n    rng = MersenneTwister(0);\r\n    rnd = rand(rng, Float64, (2, m))\r\n    rnd = rand(rng, Float64, (2, m))\r\n    for i = 1:m\r\n        nodes[1, i] = rnd[1, i]\r\n        nodes[2, i] = rnd[2, i]\r\n    end\r\n\r\n    u = Vector{Float64}(undef, m)     # function values at nodes\r\n    for i = 1:m\r\n        x = nodes[1,i]\r\n        y = nodes[2,i]\r\n        u[i] = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0\r\n    end\r\n\r\n    bnodes = get_2D_border_nodes(19)   # 80 border nodes \r\n    bn_1 = size(bnodes, 2)\r\n    d_nodes = Matrix{Float64}(undef, 2, 2 * bn_1)\r\n    es = Matrix{Float64}(undef, 2, 2 * bn_1)\r\n    du = Vector{Float64}(undef, 2 * bn_1)\r\n    k = 0\r\n    for i = 1:bn_1\r\n        k += 1\r\n        x = bnodes[1,i]\r\n        y = bnodes[2,i]\r\n        grad = [0.0; 0.0]\r\n        d_nodes[1,k] = x\r\n        d_nodes[2,k] = y\r\n        du[k] = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n        es[1,k] = 1.0\r\n        es[2,k] = 0.0\r\n        k += 1\r\n        d_nodes[1,k] = x\r\n        d_nodes[2,k] = y\r\n        du[k] = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0\r\n        es[1,k] = 0.0\r\n        es[2,k] = 1.0\r\n    end\r\n\r\n    # creating the uniform Cartesian grid of size 51x51 on [0, 1]x[0, 1]\r\n    t = 50\r\n    x = collect(range(0.0, 1.0; step = 1.0/t))\r\n    y = collect(range(0.0, 1.0; step = 1.0/t))\r\n    t1 = t + 1\r\n    grid = Matrix{Float64}(undef, 2, t1^2)\r\n    for i = 1:t1\r\n        for j = 1:t1\r\n            r = (i - 1) * t1 + j\r\n            grid[1, r] = x[i]\r\n            grid[2, r] = y[j]\r\n        end\r\n    end\r\n\r\n    # Here spline is being constructed with RK_H1 kernel,\r\n    # the value of the 'scaling parameter' ε is estimated\r\n    # in the interpolate procedure.rk = RK_H1()\r\n    #\r\n    spline = interpolate(nodes, u, d_nodes, es, du, rk)\r\n    cond = get_cond(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    # A value of the 'scaling parameter' of Bessel Potential space\r\n    # the normal spline was built in.\r\n    ε = get_epsilon(spline)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"\r\n    σ = evaluate(spline, grid)\r\n    σ = nothing","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of function phi at evaluation point p = 05 05","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    p = [0.5; 0.5]\r\n    x = p[1]\r\n    y = p[2]\r\n    f = (2.0*cos(10.0*x)*sin(10.0*y) + sin(10.0*x*y))/3.0","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Value of spline at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ = evaluate_one(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Difference of function phi and spline values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff = f - σ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of function phi at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    g1 = (10.0*y*cos(10.0*x*y) - 20.0*sin(10.0*x)*sin(10.0*y))/3.0\r\n    g2 = (20.0*cos(10.0*x)*cos(10.0*y) + 10.0*x*cos(10.0*x*y))/3.0 \r\n    f_grad = [g1; g2]","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Gradient of spline at the evaluation point","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    σ_grad = evaluate_gradient(spline, p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Norm of difference of function phi and spline gradient values at the evaluation point:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"    diff_grad = sqrt(sum((f_grad .- σ_grad).^2))","category":"page"},{"location":"Usage/#Q-and-A","page":"Example Usage","title":"Q & A","text":"","category":"section"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Q1. Question: The call","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"interpolate(x, u, RK_H3())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"cause the following error: PosDefException: matrix is not positive definite; Cholesky factorization failed. What is a reason of the error and how to resolve it?","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A1. Answer: Creating a Bessel Potential kernel object with omitted parameter ε means that this paramter will be estimated during interpolating procedure execution. It might happen that estimated value of the ε is too small and corresponding  Gram matrix of linear system of equations which defines the normal spline coefficients is very ill-conditioned and it lost its positive definiteness because of floating-point rounding errors.  ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"There are two ways to fix it.","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We can get the estimated value of ε by calling function get_epsilon():","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"ε = get_epsilon()","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"then we could try to call the interpolate function with greater ε value of the reproducing kernel parameter:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"interpolate(x, u, RK_H3(10.0*ε))","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"We may change the precision of floating point calculations. Namely it is possible to use Julia standard BigFloat numbers or Double64 - extended precision float type from the package DoubleFloats:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"using DoubleFloats\r\n\r\nx = Double64.(x)\r\nu = Double64.(u)\r\ninterpolate(x, u, RK_H3())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"This answer also applies to types RK_H1() and RK_H2().","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Q2. Question: The call","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"interpolate(x, u, RK_W3())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"cause the following error: PosDefException: matrix is not positive definite; Cholesky factorization failed. How to resolve it?","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A2. Answer: The reason of that exception is the Gram matrix of linear system of equations which defines the normal spline coefficients is very ill-conditioned and it lost its positive definiteness because of floating-point rounding errors.  ","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"The only way to fix it - is using floating-point arithmetic with extended precision. It can be provided by Julia standard BigFloat type or Double64 type from the package DoubleFloats:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"using DoubleFloats\r\n\r\nx = Double64.(x)\r\nu = Double64.(u)\r\ninterpolate(x, u, RK_W3())","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"This answer also applies to types RK_W1() and RK_W2().","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Q3. Question: The following calls","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"interpolate(x, u, RK_H3())\r\nσ = evaluate(p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"produce the output which is not quite satisfactoty. Is it possible to improve the quality of interpolation?","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"A3. Answer: Creating a Bessel Potential kernel object with omitted parameter ε means that this paramter will be estimated during interpolating procedure execution. It might happen that estimated value of the ε is too large and it is possible to use a smaller ε value which would result in better quality of interpolation. We can get the estimated value of ε by calling function get_epsilon():","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"ε = get_epsilon()","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"and get an estimation of the problem's Gram matrix condition number by calling get_cond() function:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"cond = get_cond()","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"In a case when estimated condition number is not very large, i.e. less than 10^12 using standard Float64 floating-point arithmetic, we may attempt to build a better interpolation spline by calls:","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"interpolate(x, u, RK_H3(ε/5))\r\nσ = evaluate(p)","category":"page"},{"location":"Usage/","page":"Example Usage","title":"Example Usage","text":"Another option is using a smaller value of the ε and perform calculations using extended precision floating-point arithmetic.","category":"page"},{"location":"Parameter-Choice/#Choice-of-the-scaling-parameter","page":"Choice of the scaling parameter","title":"Choice of the scaling parameter","text":"","category":"section"},{"location":"Interpolating-Normal-Splines/#Interpolating-Normal-Splines","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"","category":"section"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Consider the following interpolation problem:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Problem: Given points p_i p_i in R^n_i=1^n_1, s_j s_j in R^n_j=1^n_2 and a set of unit vectors e_j e_j in R^n_j=1^n_2 find a function f such that","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag1\r\nbeginaligned\r\n f(p_i) =  u_i   quad  i = 1 2 dots n_1  \r\n  \r\n frac partialf  partiale_j (s_j) =  v_j   quad  j = 1 2 dots n_2  \r\n\r\n n_1 gt 0       n_2 ge 0  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"where frac partialf  partiale_j (s_j) = nabla f(s_j) cdot e_j = sum _k=1^n  frac partialf  partialx_k  (s_j) e_jk is a directional derivative of f at the point s_j in the direction of e_j.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"We assume that function f is an element of the Bessel potential space H^s_varepsilon (R^n) which is defined as:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi  in L_2 (R^n) right  quad\r\n  varepsilon gt 0    s = n2 + 12 + r   quad r = 12dots  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"where  cdot  is the Euclidean norm, S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. The parameter varepsilon can be considered as a \"scaling parameter\", it allows to control approximation properties of the normal spline which usually are getting better with smaller values of varepsilon, also it can be used to reduce the ill-conditioness of the related computational problem (in traditional theory varepsilon = 1).","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Theoretical properties of spaces H^s_varepsilon at varepsilon gt 0 are identical — they are Hilbert spaces with inner product","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"langle varphi  psi rangle =\r\nint ( varepsilon ^2  +  xi ^2 )^s\r\nmathcal F varphi  overlinemathcal F psi    d xi","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"and  norm","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":" varphi  = left( langle varphi  varphi rangle right)^12 =\r\n (  varepsilon ^2 +  xi ^2 )^s2 mathcal F varphi  _L_2  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"It is easy to see that all these norms are equivalent. It means that space H^s_varepsilon (R^n) is equivalent to H^s (R^n) =  H^s_1 (R^n) ([3], [5]).","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Hilbert space H^s_varepsilon (R^n) is continuously embedded in Hölder space C_b^r(R^n) ([3],[17],[20]) of functions continuous and bounded with their first r derivatives, it means function f can be treated as an element of function class C^r(R^n) of functions continuous with their first r derivatives. Therefore functionals F_i and F_j","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"beginaligned\r\n   F_i(varphi) = varphi (p_i)     F_j(varphi) = frac partialvarphi  partiale_j (s_j)     forall varphi in H^s_varepsilon (R^n)  \r\n   quad\r\n   p_i  s_j in R^n  \r\n   \r\n   i = 1 2 dots n_1       j = 1 2 dots n_2  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"are linear continuous functionals in H^s_varepsilon.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"We also assume that all points p_i are different and in a case when among points s_j there are coincident ones, we stipulate that the corresponding unit vectors defining the directions of the directional derivatives at such points are linearly independent. Note that some points p_i may coincide with some s_j. Under these restrictions all functionals F_i  F_j are linearly independent.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"In accordance with Riesz representation theorem [1] these linear continuous functionals can be represented in the form of inner product of some elements h_i h_j in H^s_varepsilon and varphi in H^s_varepsilon, for any varphi in H^s_varepsilon:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":" F_i(varphi) = langle h_i  varphi rangle    quad  F_j(varphi) = langle h_j  varphi rangle    quad  forall varphi in H^s_varepsilon  \r\n  i = 1 2 dots n_1      j = 1 2 dots n_2  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Elements h_i and h_j are continuously differentiable functions. Thereby the original system of constraints (1) can be written in form:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag2\r\nbeginaligned\r\n f(p_i) = F_i(f) = langle h_i  f rangle  = u_i  \r\n\r\n frac partialf  partiale_j (s_j) = F_j(f) = langle h_j  f rangle = v_j    \r\n \r\n   h_i  h_j  f in H^s_varepsilon  \r\n quad\r\n  i = 1 2 dots n_1      j = 1 2 dots n_2  \r\n endaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"here all functions h_i and h_j are linear independent and system of constrains (2) defines a nonempty convex and closed set (as an intersection of hyper-planes in the Hilbert space H^s_varepsilon).","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Problem of reconstruction of function f satisfying system of constraints (2) is undetermined. We reformulate it as a problem of finding solution of this system of constraints that has minimal norm:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag3\r\n   sigma = rm argmin   f - z ^2  (2) z in H^s_varepsilon  forall f in H^s_varepsilon   ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"where z in H^s_varepsilon is a \"prototype\" function. Solution of this problem exists and it is unique ([6], [16]) as a projection of element z on the nonempty convex closed set in Hilbert space H^s_varepsilon. Element sigma is an interpolating normal spline.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"In accordance with generalized Lagrange method ([13], [16]) solution of the problem (3) can be presented as:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag4\r\nsigma =  z + sum _i=1^n_1 mu_i  h_i  + sum _j=1^n_2 mu_j  h_j   ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"where coefficients mu_i and mu_j are defined by system of linear equations","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag5\r\n    sum _l=1^n_1 g_il mu_l + sum _j=1^n_2 g_ij mu_j   =  u_i - langle h_i  z rangle   quad 1 le i le n_1         sum _i=1^n_1 g_ij mu_i + sum _m=1^n_2 g_jm mu_m =  v_j - langle h_j  z rangle    quad 1 le j le n_2  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Matrix of system (5) is the positive definite symmetric Gram matrix of the set of linearly independent elements  h_i h_j and coefficients g_il g_ij g_jm are defined as follows:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag6\r\n   g_il = langle h_i  h_l rangle     g_ij = langle h_i  h_j rangle      g_jm = langle h_j  h_m rangle  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Space H^s_varepsilon (R^n) is a reproducing kernel Hilbert space ([5],[18],[19],[20]). We denote its reproducing kernel as V(eta xi).","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Recall the definition of the reproducing kernel ([4], [7]). The reproducing kernel of space H^s_varepsilon is a such function V(eta xi) that","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"for every xi in R^n,  V(eta xi) as function of eta belongs to H^s_varepsilon\nfor every xi in R^n and every function varphi in H^s_varepsilon","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag7\r\nvarphi(xi) = langle V(eta xi)  varphi(eta) rangle","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Reproducing kernel is a symmetric function:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"V(eta xi) = V(xi eta)  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"also in the considered case (s = n2 + 12 + r  r ge 1) it is a continuously differentiable function. Differentiating the identity (7) allows to get the identities for derivatives:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag8\r\nfrac partial varphi(xi)partial xi_k = left langle fracpartial V(cdot xi) partial xi_k varphi right rangle","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"which holds for any varphi in H^s_varepsilon and xi in R^n, it means that function fracpartial V(cdot  xi) partialxi_k represents a point-wise functional defined as value of function frac partial varphi (cdot) partialxi_k at the point xi.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Now it is possible to express functions h_i and h_j via the reproducing kernel V. Comparing (2) with (7) and (8) we receive:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag9\r\nbeginaligned\r\n  h_i (eta) =  V(eta p_i)    qquad qquad qquad qquad qquad   i = 1 2 dots n_1    \r\n  h_j (eta) =  fracpartial V(eta s_j)partial e_j =  sum_k=1^n  frac partial V(eta s_j) partialxi_k e_jk    quad  j = 1 2 dots n_2    \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"The coefficients (6) of the Gram matrix can be presented as ([7], [8], [10]):","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag10\r\nbeginaligned\r\n    g_il = langle h_i  h_l rangle = langle V(cdot p_i)  V(cdot p_l) rangle = V(p_i p_l)  \r\n   \r\n     g_ij = langle h_i  h_j rangle = left langle V(cdot p_i) fracpartial V(cdot s_j)partial e_j right rangle =  fracpartial V(p_i s_j)partial e_j =\r\n    \r\n     qquad qquad qquad =  sum_k=1^n  frac partial V(p_i s_j) partialxi_k e_jk   \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"With the help of (7) and (10), we can also calculate g_jm ([8], [10]):","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag11\r\nbeginaligned\r\n g_jm = langle h_j  h_m rangle   =  left langle fracpartial V(cdot s_j)partial e_j fracpartial V(cdot s_m)partial e_m right rangle   =  frac partial^2 V(s_j s_m) partial e_j partial e_m =\r\n \r\n   =  sum_r=1^n sum_k=1^n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k e_jk e_mr  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Further","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag12\r\nbeginaligned\r\n   langle h_i  z rangle  =  langle V(cdot p_i)  z rangle = z(p_i)   \r\n  \r\n   langle h_j  z rangle  = fracpartial z(s_j)partial e_j = sum_k=1^n  frac partial z(s_j) partialx_k e_jk  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Here normal hermite splines will be constructed in Bessel potential spaces H^s_1_varepsilon (R^n)   s_1 = n2 + 32 and H^s_2_varepsilon (R^n)   s_2 = n2 + 52. Elements of space H^s_1 can be treated as  continuously differentiable functions and elements of space H^s_2 can be treated as twice continuously differentiable functions. Note, the spline is infinitely differentiable everywhere in R^n excepting the knots p_i and s_j.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Reproducing kernel of Bessel potential space was presented in [5] and its simplified form was given in [14], [18], [19], [20]. For space H^s_varepsilon (R^n)  s = n2 + 12 + r  r ge 0 it can be written as:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":" V(eta  xi) = exp (-varepsilon eta - xi) \r\n     sum_k=0^r frac(r+k)2^k k (r-k) (varepsilon eta - xi)^r-k  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"(a constant multiplier is omitted here.)","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"This reproducing kernel is known as the Matérn kernel [23].","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Therefore for space H^s_1_varepsilon (R^n) with accuracy to constant multiplier we get:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag13\r\nV(eta xi) =  exp (-varepsilon eta - xi)\r\n             (1 + varepsilon eta - xi)  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"and for space H^s_2_varepsilon (R^n):","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag14\r\nV(eta xi) =  exp (-varepsilon eta - xi)\r\n             (3 + 3varepsilon eta - xi + varepsilon ^2 eta - xi ^2 )  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Let's write down expressions of h_i h_j g_il g_ij g_jm for space H^s_1_varepsilon (R^n):","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag15\r\nbeginaligned\r\n h_i (eta) =  exp (-varepsilon eta - p_i ) (1 + varepsilon eta - p_i)   qquad  quad   i = 1 2 dots n_1   \r\n h_j (eta) = varepsilon^2 exp (-varepsilon  eta - s_j  ) sum _k=1^n (eta_k - s_jk) e_jk   quad  j = 1 2 dots n_2   \r\n g_il= exp (-varepsilon  p_i - p_l  )(1 + varepsilon  p_i - p_l  )      quad     i = 1 2 dots n_1     l = 1 2 dots n_1   \r\n g_ij = varepsilon^2 exp (-varepsilon p_i - s_j  ) sum _k=1^n (p_ik - s_jk) e_jk      i = 1 2 dots n_1     j = 1 2 dots n_2  \r\n\r\n g_jm =  sum_r=1^n sum_k=1^n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k e_jk e_mr\r\n\r\n quad qquad j ne m   quad j = 1 2 dots n_2     m = 1 2 dots n_2  \r\n\r\n textwhere\r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_r = varepsilon^2 exp (-varepsilon  s_j - s_m ) left (1 - varepsilon frac (s_jr - s_mr)^2 s_j - s_m  right)  \r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k = -varepsilon^3 exp (-varepsilon  s_j - s_m ) frac (s_jr - s_mr)(s_jk - s_mk) s_j - s_m     quad r ne k  \r\n\r\n g_jj = varepsilon^2 sum _r=1^n  (e_jr)^2  = varepsilon^2    quad j = 1 2 dots n_2  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"and for space H^s_2_varepsilon (R^n):","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag16\r\nbeginaligned\r\n h_i (eta) =  exp (-varepsilon eta - p_i ) (3 + 3 varepsilon eta - p_i  +  varepsilon^2  eta - p_i ^2) )\r\n   qquad quad i = 1 2 dots n_1   \r\n h_j (eta) =varepsilon^2 exp (-varepsilon eta - s_j  ) (1 + varepsilon eta - s_j ) sum _k=1^n (eta_k - s_jk) e_jk   quad  j = 1 2 dots n_2   \r\n g_il= exp (-varepsilon p_i - p_l ) (3 + 3 varepsilon p_i - p_l  +  varepsilon^2  p_i - p_l ^2) )  \r\n\r\n qquad qquad qquad qquad qquad qquad qquad i = 1 2 dots n_1     l = 1 2 dots n_1   \r\n g_ij = varepsilon^2 exp (-varepsilon p_i - s_j  ) (1 + varepsilon p_i - s_j ) sum _k=1^n (p_ik - s_jk) e_jk   \r\n\r\n qquad qquad qquad qquad qquad qquad qquad  i = 1 2 dots n_1     j = 1 2 dots n_2  \r\n\r\n g_jm =  sum_r=1^n sum_k=1^n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k e_jk e_mr\r\n\r\n quad qquad j ne m   quad j = 1 2 dots n_2     m = 1 2 dots n_2  \r\n\r\n textwhere\r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_r = varepsilon^2 exp (-varepsilon  s_j - s_m ) (1 + varepsilon  s_j - s_m  - varepsilon^2 (s_jr - s_mr)^2)  \r\n\r\n  frac partial^2 V(s_j s_m) partialeta_r partialxi_k = -varepsilon^4 exp (-varepsilon  s_j - s_m ) (s_jr - s_mr)(s_jk - s_mk)    quad r ne k  \r\n\r\n g_jj = varepsilon^2 sum _r=1^n  (e_jr)^2  = varepsilon^2    quad j = 1 2 dots n_2  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"In a case when there is no information of function f derivatives the Problem (1) is reducing to the simplest interpolation problem:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Problem: Given points p_i p_i in R^n_i=1^n_1 find a function f such that","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag17\r\nbeginaligned\r\n f(p_i) =  u_i   quad  i = 1 2 dots n_1  \r\n\r\n n_1 gt 0  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"We assume that f is a continuous function. It can be treated as an element of Bessel potential space H_varepsilon^s_0 (R^n)   s_0 =  n2 + 12, this space is continuously embedded in Hölder space C_b(R^n) of continuous and bounded functions.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"Reproducing kernel of Bessel potential space H_varepsilon^s_0(R^n) can be written as:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"V(eta  xi) = exp (-varepsilon eta - xi)  ","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"(with accuracy to a constant multipliler), and expressions for h_i g_il are defined by:","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"tag18\r\nbeginaligned\r\n h_i (eta) = exp (-varepsilon eta - p_i )   quad  i = 1 2 dots n_1  \r\n \r\n g_il = exp (-varepsilon  p_i - p_l  ))  \r\n  quad\r\ni = 1 2 dots n_1     l = 1 2 dots n_1  \r\nendaligned","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"When value of the parameter varepsilon is small this normal spline is similar to multivariate generalization of the one dimensional linear spline.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"We now consider the choice of value for parameterd varepsilon. In a case when value of this parameter is small the normal spline is similar to Duchon's D^m -spline [12]. Approximating properties of the normal spline are getting better with smaller values of varepsilon, however with decreasing value of varepsilon the condition number of the corresponding Gram matrix is increasing. Therefore, when choosing the value of parameter varepsilon, a compromise is needed. In practice, it is necessary to choose such value of the varepsilon that condition number of Gram matrix is small enough. Numerical procedures of the matrix condition number estimation are well known.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"As well, it is useful to preprocess the source data of the problem by transforming the domain where interpolation knots are located into the unit hypercube.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"The normal splines method for one-dimensional function interpolation and linear ordinary differential and integral equations was proposed in [8] and [9] and developed in [10]. Multivariate generalization of the normal splines method was developed for two-dimensional problem of low-range computerized tomography in [15] and applied for solving a mathematical economics problem in [11]. Further results were reported on seminars and conferences [14,21,22].","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"References","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[1]  R. Adams, J. Fournier, Sobolev Spaces. Pure and Applied Mathematics. (2nd ed.). Boston, MA: Academic Press, 2003.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[2] D. Adams, L. Hedberg, Function spaces and potential theory. Berlin, Springer, 1996.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[3] M. Agranovich, Sobolev Spaces, Their Generalizations and Elliptic Problems in Smooth and Lipschitz Domains, Springer, Switzerland, 2015.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[4] N. Aronszajn, Theory of reproducing kernels, Tranzactions of the AMS, Vol. 68, No. 3, 1950.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[5] N. Aronszajn, K.T. Smith, Theory of bessel potentials I, Ann.Inst.Fourier, Vol. 11, 1961.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[6] A. Balakrishnan, Applied Functional Analysis, New York, Springer-Verlag, 1976.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[7] A. Bezhaev, V. Vasilenko, Variational Theory of Splines, Springer US, 2001.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[8] V. Gorbunov, The method of normal spline collocation, USSR Computational Mathematics and Mathematical Physics, Vol. 29, No. 1, 1989.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[9] V. Gorbunov, Extremum Problems of Measurements Data Processing, Ilim, 1990 (in Russian).","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[10] V. Gorbunov, V. Petrishchev, Improvement of the normal spline collocation method for linear differential equations, Comput. Math. Math. Phys., Vol. 43, No. 8, 2003.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[11] V. Gorbunov, I. Kohanovsky, K. Makedonsky, Normal splines in reconstruction of multi-dimensional dependencies. Papers of WSEAS International Conference on Applied Mathematics, Numerical Analysis Symposium, Corfu, 2004.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[12] J. Duchon, Splines minimizing rotation-invariant semi-norms in Sobolev spaces, Lect. Notes in Math., Vol. 571, Springer, Berlin, 1977","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[13] A. Ioffe, V. Tikhomirov, Theory of extremal problems, North-Holland, Amsterdam, 1979.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[14] I. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[15] I. Kohanovsky, Normal Splines in Computing Tomography, Avtometriya, 1995, N 2.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[16] P.-J. Laurent, Approximation et optimization, Paris, 1972.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[17] H. Triebel, Interpolation. Function Spaces. Differential Operators. North-Holland, Amsterdam, 1978.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[18] R. Schaback, Kernel-based Meshless Methods, Lecture Notes, Goettingen, 2011.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[19] H. Wendland, Scattered Data Approximation. Cambridge University Press, 2005.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[20] Reproducing Kernel of Bessel Potential space.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[21] V. Gorbunov, I. Kohanovsky, Heterogeneous Parallel Method for the Construction of Multi-dimensional Smoothing Splines. ESCO 2014 4th European Seminar on Computing, 2014.","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[22] I. Kohanovsky, Inequality-Constrained Multivariate Normal Splines with Some Applications in Finance. 27th GAMM-Seminar Leipzig on Approximation of Multiparametric functions, 2011","category":"page"},{"location":"Interpolating-Normal-Splines/","page":"Interpolating Normal Splines","title":"Interpolating Normal Splines","text":"[23] G. Fasshauer, M. McCourt, Kernel-Based Approximation Methods Using Matlab, World Scientific, Singapore, 2015.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author = \"Igor Kohanovsky\"","category":"page"},{"location":"#NormalHermiteSplines.jl","page":"Home","title":"NormalHermiteSplines.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multivariate Normal Hermite Splines in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"NormalHermiteSplines.jl implements the normal splines method for solving following interpolation problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem:   Given points p_i p_i in R^n_i=1^n_1, s_j s_j in R^n_j=1^n_2 and a set of unit vectors e_j e_j in R^n_j=1^n_2 find a function f such that","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag1\r\nbeginaligned\r\n f(p_i) =  u_i   quad  i = 1 2 dots n_1  \r\n  \r\n frac partialf  partiale_j (s_j) =  v_j   quad  j = 1 2 dots n_2  \r\n\r\n n_1 gt 0       n_2 ge 0  \r\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where frac partialf  partiale_j (s_j) = nabla f(s_j) cdot e_j = sum _k=1^n  frac partialf  partialx_k  (s_j) e_jk is a directional derivative of f at the point s_j in the direction of e_j.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We assume that function f is an element of the Bessel potential space H^s_varepsilon (R^n) which is defined as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"   H^s_varepsilon (R^n) = left varphi  varphi in S \r\n  ( varepsilon ^2 +  xi ^2 )^s2mathcal F varphi  in L_2 (R^n) right  quad\r\n  varepsilon gt 0    s = n2 + 12 + r   quad r = 12dots  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where  cdot  is the Euclidean norm, S  (R^n) is space of L. Schwartz tempered distributions, parameter s may be treated as a fractional differentiation order and mathcal F varphi  is a Fourier transform of the varphi. The parameter varepsilon can be considered as a \"scaling parameter\", it allows to control approximation properties of the normal spline which usually are getting better with smaller values of varepsilon, also it can be used to reduce the ill-conditioness of the related computational problem (in traditional theory varepsilon = 1).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Bessel potential space H^s_varepsilon (R^n) is a Hilbert space, an element f from that space can be treated as a r-times continuously differentiable function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method consists in finding a solution of system (1) having minimal norm in Hilbert space H^s_varepsilon (R^n)  thus the interpolation normal spline sigma is defined as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag2\r\n   sigma = rm argmin   f ^2  (1) forall f in H^s_varepsilon (R^n)   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Normal splines method is based on the following functional analysis results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bessel potential space embedding theorem\nThe Riesz representation theorem for Hilbert spaces\nReproducing kernel properties","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using these results it is possible to reduce the task (2) to solving a system of linear equations with symmetric positive definite Gram matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Detailed explanation is given in Multivariate Normal Hermite Splines","category":"page"},{"location":"","page":"Home","title":"Home","text":"The normal splines method for one-dimensional function interpolation and linear ordinary differential and integral equations was proposed in [1]. Multivariate generalization of the normal splines method was developed for two-dimensional problem of low-range computerized tomography in [2] and applied for solving a mathematical economics problem in [3]. Further results were reported at the seminars and conferences [4,5,6].","category":"page"},{"location":"#References:","page":"Home","title":"References:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"V. Gorbunov, The method of normal spline collocation. USSR Computational Mathematics and Mathematical Physics, Vol. 29, No. 1, 1989\nI. Kohanovsky, Normal Splines in Computing Tomography (in Russian). Avtometriya, No. 2, 1995\nV. Gorbunov, I. Kohanovsky, K. Makedonsky, Normal splines in reconstruction of multi-dimensional dependencies. Papers of WSEAS International Conference on Applied Mathematics, Numerical Analysis Symposium, Corfu, 2004\nI. Kohanovsky, Multidimensional Normal Splines and Problem of Physical Field Approximation, International Conference on Fourier Analysis and its Applications, Kuwait, 1998.\nI. Kohanovsky, Inequality-Constrained Multivariate Normal Splines with Some Applications in Finance. 27th GAMM-Seminar Leipzig on Approximation of Multiparametric functions, 2011\nV. Gorbunov, I. Kohanovsky, Heterogeneous Parallel Method for the Construction of Multi-dimensional Smoothing Splines. ESCO 2014 4th European Seminar on Computing, 2014","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\r\n      \"index.md\",\r\n      \"Public-API.md\",\r\n      \"Usage.md\",\r\n      \"Parameter-Choice.md\",\r\n      \"Numerical-Tests.md\",\r\n      \"Tests-with-real-data.md\",\r\n      \"Interpolating-Normal-Splines.md\",\r\n      \"Reproducing-Kernel-of-Bessel-Potential-space.md\",\r\n      \"Relation-to-Polyharmonic-Splines.md\",\r\n      \"Updating-Cholesky-Factorization.md\"\r\n]\r\nDepth = 3","category":"page"},{"location":"Numerical-Tests/#Numerical-Tests","page":"Numerical Tests","title":"Numerical Tests","text":"","category":"section"},{"location":"Numerical-Tests/#D-interpolation-case","page":"Numerical Tests","title":"2D interpolation case","text":"","category":"section"},{"location":"Numerical-Tests/#Grids","page":"Numerical Tests","title":"Grids","text":"","category":"section"},{"location":"Numerical-Tests/#Models","page":"Numerical Tests","title":"Models","text":"","category":"section"},{"location":"Numerical-Tests/","page":"Numerical Tests","title":"Numerical Tests","text":"bb","category":"page"},{"location":"Numerical-Tests/#Tests","page":"Numerical Tests","title":"Tests","text":"","category":"section"},{"location":"Numerical-Tests/","page":"Numerical Tests","title":"Numerical Tests","text":"c","category":"page"},{"location":"Numerical-Tests/#D-interpolation-case-2","page":"Numerical Tests","title":"3D interpolation case","text":"","category":"section"},{"location":"Numerical-Tests/#Grids-2","page":"Numerical Tests","title":"Grids","text":"","category":"section"},{"location":"Numerical-Tests/#Models-2","page":"Numerical Tests","title":"Models","text":"","category":"section"},{"location":"Numerical-Tests/","page":"Numerical Tests","title":"Numerical Tests","text":"h","category":"page"},{"location":"Numerical-Tests/#Tests-2","page":"Numerical Tests","title":"Tests","text":"","category":"section"},{"location":"Numerical-Tests/","page":"Numerical Tests","title":"Numerical Tests","text":"j","category":"page"}]
}
