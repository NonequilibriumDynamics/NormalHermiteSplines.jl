<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · NormalHermiteSplines.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NormalHermiteSplines.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Usage/">Example Usage</a></li><li><a class="tocitem" href="../Numerical-Tests/">Numerical Tests</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../Interpolating-Normal-Hermite-Splines/">Interpolating Normal Hermite Splines</a></li><li><a class="tocitem" href="../Relation-to-Polyharmonic-Splines/">Relation to Polyharmonic Splines</a></li><li><a class="tocitem" href="../Reproducing-Kernel-of-Bessel-Potential-space/">Reproducing Kernel of Bessel Potential space</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/master/docs/src/Public-API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.interpolate" href="#NormalHermiteSplines.interpolate"><code>NormalHermiteSplines.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>interpolate(nodes::Matrix{T}, values::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Create a normal spline by <code>values</code> of function defined at <code>nodes</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: Locations where function values are defined.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>values::Vector{T}</code>: function values at <code>n_1</code> interpolation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: a completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function         to interpolate the data to required points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L100-L118">source</a></section><section><div><p><code>interpolate(nodes::Matrix{T}, values::Vector{T}, d_nodes::Matrix{T}, es::Matrix{T}, d_values::Vector{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Create a normal spline by <code>values</code> of function defined at <code>nodes</code> and <code>d_values</code> of function directional derivatives defined at <code>d_nodes</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: Locations where function values are defined.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>values::Vector{T}</code>: function values at <code>n_1</code> interpolation nodes.</li><li><code>d_nodes</code>: Locations where function directional derivatives are defined.           This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and           <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.      This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and      <code>n_2</code> is the number of function directional derivative nodes.      It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>d_values::Vector{T}</code>: function directional derivative values at <code>n_2</code> interpolation nodes.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: a completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function         to interpolate the data to required points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L241-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.prepare" href="#NormalHermiteSplines.prepare"><code>NormalHermiteSplines.prepare</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>prepare(nodes::Matrix{T}, kernel::RK = RK_H0()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Prepare a normal spline by constructing and factorizing Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: Locations where function values are defined.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes. It means that each column in the matrix defines one node.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H0</code> if the spline is constructing as a continuous function,             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: a partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function         in order to complete the spline initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L56-L73">source</a></section><section><div><p><code>prepare(nodes::Matrix{T}, d_nodes::Matrix{T}, es::Matrix{T}, kernel::RK = RK_H1()) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_1}</code></p><p>Prepare a normal spline by constructing and factorizing Gram matrix of the interpolation problem. Initialize the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: Locations where function values are defined.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_1</code> is the number of function value nodes.           It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: Locations where function directional derivatives are defined.            This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and            <code>n_2</code> is the number of function directional derivative nodes.</li><li><code>es</code>: Directions of the function directional derivatives.       This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and       <code>n_2</code> is the number of function directional derivative nodes.       It means that each column in the matrix defines one direction of the function directional derivative.</li><li><code>kernel</code>: reproducing kernel of Bessel potential space the normal spline is constructed in.           It must be a struct object of the following type:             <code>RK_H1</code> if the spline is constructing as a differentiable function,             <code>RK_H2</code> if the spline is constructing as a twice differentiable function.</li></ul><p>Return: a partly initialized <code>NormalSpline</code> object that must be passed to <code>construct</code> function         in order to complete the spline initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L186-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.construct" href="#NormalHermiteSplines.construct"><code>NormalHermiteSplines.construct</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>construct(spline::NormalSpline{T, RK}, values::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Construct an interpolating spline by calculating coefficients of the spline and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values::Vector{T}</code>: function values at <code>n_1</code> interpolation nodes.</li></ul><p>Return: a completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function         to interpolate the data to required points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L81-L92">source</a></section><section><div><p><code>construct(spline::NormalSpline{T, RK}, values::Vector{T}, d_values::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Construct an interpolating spline by calculating coefficients of the spline and completely initializing the <code>NormalSpline</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a partly initialized <code>NormalSpline</code> object returned by <code>prepare</code> function.</li><li><code>values::Vector{T}</code>: function values at <code>n_1</code> interpolation nodes.</li><li><code>d_values::Vector{T}</code>: function directional derivative values at <code>n_2</code> interpolation nodes.</li></ul><p>Return: a completely initialized <code>NormalSpline</code> object that can be passed to <code>evaluate</code> function         to interpolate the data to required points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L220-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.evaluate" href="#NormalHermiteSplines.evaluate"><code>NormalHermiteSplines.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate(spline::NormalSpline{T, RK}, points::Matrix{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate normal spline at the locations defined in <code>points</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>points::Matrix{T}</code>: locations at which spline values are evaluating.                      This should be an <code>n×m</code> matrix, where <code>n</code> is dimension of the sampled space                      and <code>m</code> is the number of locations where spline values are evaluating.                      It means that each column in the matrix defines one location.</li></ul><p>Return: <code>Vector{T}</code> of spline values at the locations defined in <code>points</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L128-L141">source</a></section><section><div><p><code>evaluate(spline::NormalSpline{T, RK}, point::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate normal spline at the location defined in <code>point</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point::Vector{T}</code>: location at which spline value is evaluating.                      This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p>Return: spline value at the location defined in <code>point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L148-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.evaluate_grad" href="#NormalHermiteSplines.evaluate_grad"><code>NormalHermiteSplines.evaluate_grad</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>evaluate_grad(spline::NormalSpline{T, RK}, point::Vector{T}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Evaluate a gradient of the normal spline at the location defined in <code>point</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a <code>NormalSpline</code> object returned by <code>interpolate</code> or <code>construct</code> function.</li><li><code>point::Vector{T}</code>: location at which gradient value is evaluating.                      This should be a vector of size <code>n</code>, where <code>n</code> is dimension of the sampled space.</li></ul><p>Return: <code>Vector{T}</code> - gradient of the normal spline at the location defined in <code>point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L166-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.estimate_interpolation_quality" href="#NormalHermiteSplines.estimate_interpolation_quality"><code>NormalHermiteSplines.estimate_interpolation_quality</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_interpolation_quality(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Estimate the interpolation quality</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a <code>NormalSpline</code> object returned by <code>construct</code> or <code>interpolate</code> function.</li></ul><p>Return: RMSE of interpolation at function value nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L363-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.get_cond" href="#NormalHermiteSplines.get_cond"><code>NormalHermiteSplines.get_cond</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_cond(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get an estimation of the Gram matrix condition number. (C. Brás, W. Hager, J. Júdice, An investigation of feasible descent algorithms for estimating the condition number of a matrix. TOP Vol.20, No.3, 2012.)</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a <code>NormalSpline</code> object returned by <code>prepare</code>, <code>construct</code> or <code>interpolate</code> function.</li></ul><p>Return: an estimation of the Gram matrix condition number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L338-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.get_epsilon" href="#NormalHermiteSplines.get_epsilon"><code>NormalHermiteSplines.get_epsilon</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>get_epsilon(spline::NormalSpline{T, RK}) where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Get a <code>ε</code> - &#39;scaling parameter&#39; of Bessel Potential space the normal spline was built in.</p><p><strong>Arguments</strong></p><ul><li><code>spline::NormalSpline{T, RK}</code>: a <code>NormalSpline</code> object returned by <code>prepare</code>, <code>construct</code> or <code>interpolate</code> function.</li></ul><p>Return: <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L280-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.estimate_epsilon" href="#NormalHermiteSplines.estimate_epsilon"><code>NormalHermiteSplines.estimate_epsilon</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>estimate_epsilon(nodes::Matrix{T}) where T &lt;: AbstractFloat</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the normal spline was built in. This coinsides with result returned by <code>get_epsilon</code> function if all <code>nodes</code> are located in a unit hypercube, othewise the estimated value of <code>ε</code> can be significantly higher then necessary.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: Locations where function values are defined.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L294-L307">source</a></section><section><div><p><code>estimate_epsilon(nodes::Matrix{T}, d_nodes::Matrix{T}) where T &lt;: AbstractFloat</code></p><p>Get an the estimation of the &#39;scaling parameter&#39; of Bessel Potential space the normal spline was built in. This coinsides with result returned by <code>get_epsilon</code> function if all <code>nodes</code> and <code>d_nodes</code> are located in a unit hypercube, othewise the estimated value of <code>ε</code> can be significantly higher then necessary.</p><p><strong>Arguments</strong></p><ul><li><code>nodes</code>: Locations where function values are defined.          This should be an <code>n×n_1</code> matrix, where <code>n</code> is dimension of the sampled space          and <code>n_1</code> is the number of function value nodes.          It means that each column in the matrix defines one node.</li><li><code>d_nodes</code>: Locations where function directional derivatives are defined.          This should be an <code>n×n_2</code> matrix, where <code>n</code> is dimension of the sampled space and          <code>n_2</code> is the number of function directional derivative nodes.</li></ul><p>Return: estimation of <code>ε</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L314-L330">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="Bessel-Potential-space-Reproducing-Kernels"><a class="docs-heading-anchor" href="#Bessel-Potential-space-Reproducing-Kernels">Bessel Potential space Reproducing Kernels</a><a id="Bessel-Potential-space-Reproducing-Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Bessel-Potential-space-Reproducing-Kernels" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.RK_H0" href="#NormalHermiteSplines.RK_H0"><code>NormalHermiteSplines.RK_H0</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H0{T &lt;: AbstractFloat} &lt;: ReproducingKernel_0</code></p><p>Define a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 1/2}_ε (R^n)$</span>:</p><div>\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|) \, .\]</div><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/ReproducingKernels.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.RK_H1" href="#NormalHermiteSplines.RK_H1"><code>NormalHermiteSplines.RK_H1</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H1{T &lt;: AbstractFloat} &lt;: ReproducingKernel_1</code></p><p>Define a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 3/2}_ε (R^n)$</span>:</p><div>\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (1 + \varepsilon |\xi  - \eta|) \, .\]</div><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/ReproducingKernels.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.RK_H2" href="#NormalHermiteSplines.RK_H2"><code>NormalHermiteSplines.RK_H2</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct RK_H2{T &lt;: AbstractFloat} &lt;: ReproducingKernel_2</code></p><p>Define a type of reproducing kernel of Bessel Potential space <span>$H^{n/2 + 5/2}_ε (R^n)$</span>:</p><div>\[V(\eta , \xi, \varepsilon) = \exp (-\varepsilon |\xi - \eta|)
             (3 + 3\varepsilon |\xi  - \eta| + \varepsilon ^2 |\xi - \eta| ^2 ) \, .\]</div><p><strong>Fields</strong></p><ul><li><code>ε::T</code>: &#39;scaling parameter&#39; from the Bessel Potential space definition,          it may be omitted in the struct constructor otherwise it must be greater than zero</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/ReproducingKernels.jl#L58-L70">source</a></section></article><h3 id="NormalSpline-structure"><a class="docs-heading-anchor" href="#NormalSpline-structure">NormalSpline structure</a><a id="NormalSpline-structure-1"></a><a class="docs-heading-anchor-permalink" href="#NormalSpline-structure" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NormalHermiteSplines.NormalSpline" href="#NormalHermiteSplines.NormalSpline"><code>NormalHermiteSplines.NormalSpline</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct NormalSpline{T, RK} &lt;: AbstractSpline where {T &lt;: AbstractFloat, RK &lt;: ReproducingKernel_0}</code></p><p>Define a structure containing full information of a normal spline</p><p><strong>Fields</strong></p><ul><li><code>_kernel</code>: a reproducing kernel spline was built with.</li><li><code>_compression</code>: factor of transforming the original node locations into unit hypercube</li><li><code>_nodes</code>: transformed function value nodes</li><li><code>_values</code>: function values at interpolation nodes</li><li><code>_d_nodes</code>: transformed function derivative nodes</li><li><code>_es</code>: normalized derivative directions</li><li><code>_d_values</code>: function directional derivative values</li><li><code>_min_bound</code>: minimal bounds of the original node locations area</li><li><code>_gram</code>: Gram matrix of the problem</li><li><code>_chol</code>: Cholesky factorization of the Gram matrix</li><li><code>_mu</code>: spline coefficients</li><li><code>_cond</code>: estimation of the Gram matrix condition number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/84a6540598563b35a17c446fb1def4de14ca222f/src/NormalHermiteSplines.jl#L19-L37">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#NormalHermiteSplines.construct"><code>NormalHermiteSplines.construct</code></a></li><li><a href="#NormalHermiteSplines.estimate_epsilon"><code>NormalHermiteSplines.estimate_epsilon</code></a></li><li><a href="#NormalHermiteSplines.estimate_interpolation_quality"><code>NormalHermiteSplines.estimate_interpolation_quality</code></a></li><li><a href="#NormalHermiteSplines.evaluate"><code>NormalHermiteSplines.evaluate</code></a></li><li><a href="#NormalHermiteSplines.evaluate_grad"><code>NormalHermiteSplines.evaluate_grad</code></a></li><li><a href="#NormalHermiteSplines.get_cond"><code>NormalHermiteSplines.get_cond</code></a></li><li><a href="#NormalHermiteSplines.get_epsilon"><code>NormalHermiteSplines.get_epsilon</code></a></li><li><a href="#NormalHermiteSplines.interpolate"><code>NormalHermiteSplines.interpolate</code></a></li><li><a href="#NormalHermiteSplines.prepare"><code>NormalHermiteSplines.prepare</code></a></li><li><a href="#NormalHermiteSplines.NormalSpline"><code>NormalHermiteSplines.NormalSpline</code></a></li><li><a href="#NormalHermiteSplines.RK_H0"><code>NormalHermiteSplines.RK_H0</code></a></li><li><a href="#NormalHermiteSplines.RK_H1"><code>NormalHermiteSplines.RK_H1</code></a></li><li><a href="#NormalHermiteSplines.RK_H2"><code>NormalHermiteSplines.RK_H2</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Numerical-Tests/">« Numerical Tests</a><a class="docs-footer-nextpage" href="../Interpolating-Normal-Hermite-Splines/">Interpolating Normal Hermite Splines »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 28 July 2020 12:03">Tuesday 28 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
