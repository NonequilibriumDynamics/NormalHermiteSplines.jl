<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · NormalHermiteSplines.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NormalHermiteSplines.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Public-API/">Public API</a></li><li><a class="tocitem" href="../Usage/">Example Usage</a></li><li><a class="tocitem" href="../Parameter-Choice/">Selecting a good value of the scaling parameter</a></li><li><a class="tocitem" href="../Numerical-Tests/">Numerical Tests</a></li><li><a class="tocitem" href="../Tests-with-real-data/">Tests with real data</a></li><li><a class="tocitem" href="../Normal-Splines-Method/">Normal Splines Method</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IgorKohan/NormalHermiteSplines.jl/blob/master/docs/src/Quadratic Programming in Hilbert space. Part I.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>﻿In this topic an algorithm for finding a normal solution of system of linear inequalities in Hilbert space is described. An original version of this algorithm was developed by V. Gorbunov and published in [3]. A modified version of that algorithm was presented in [6].</p><p>Let <span>$H$</span> be a Hilbert space with inner product <span>${\langle \cdot \, , \cdot \rangle}_H$</span> and the induced norm <span>$\| \cdot \|_H$</span>, there are elements <span>$h_i \in H$</span>, numbers <span>$u_i, \, 1 \le i \le M+L$</span> and positive numbers  <span>$\delta _i, \, 1 \le i \le M$</span>. It is required to minimize functional <span>$J$</span>:</p><div>\[\tag{1}
   (J, \varphi) =  {\| \varphi \|}_H ^2 \to \min \ ,\]</div><p>subject to constraints</p><div>\[\begin{aligned}
\tag{2}
&amp;    {\langle h_i , \varphi \rangle}_H = u_i \, ,
    \qquad\qquad\qquad 1 \le i \le L \ ,
\\
&amp;    | {\langle h_{i+L} , \varphi \rangle}_H - u_{i+L} | \le \delta _i \, ,
    \quad \ \ 1 \le i \le M \, , \ \varphi \in H.
\end{aligned}\]</div><p>The elements <span>$h_i, \, 1 \le i \le M+L$</span> are assumed to be linearly independent (thereby the system (2) is compatible). Solution of the problem (1)—(2) obviously exists and is unique as a solution of the problem of finding a projection of zero element of Hilbert space onto a nonempty convex closed set [1, 5]. Expanding the modules in (2) we rewrite it in form:</p><div>\[\begin{aligned}
\tag{3}
&amp;    {\langle h_i , \varphi \rangle}_H = b_i \,\quad 1 \le i \le L \ ,
\\
&amp;    {\langle h_i , \varphi \rangle}_H \le b_i \,\quad L+1 \le i \le N \ ,
\end{aligned}\]</div><p>where:</p><div>\[\begin{aligned}
&amp;  N = L + 2M \, ,
\\ 
&amp; S = L + M \,  ,
\\ 
 &amp;  b_i = u_i \,  , \quad  1 \le i \le L \, ,
\\ 
 &amp;  b_{i+L} = u_{i+L} + \delta _i \  , \
   b_{i+S} = -u_{i+L} + \delta _i \  , \
   h_{i+S} = -h_{i+L} \ , \  1 \leq i \leq M \ .
\end{aligned}\]</div><p>Let <span>$\Phi$</span> is a convex set defined by constraints (4) and (5). We denote</p><p>\begin{eqnarray}  &amp;&amp; I<em>1 = \lbrace 1, \dots , L \rbrace \,  , \quad I</em>2 = \lbrace L+1, \dots , N \rbrace \,  , \ \nonumber  &amp;&amp;  I = I<em>1 \cup I</em>2 = \lbrace 1, \dots , N \rbrace \, , \ \nonumber  &amp;&amp;  A(\varphi) = \lbrace i \in I : \langle h<em>i , \varphi \rangle</em>H = b<em>i \rbrace \, ,  \  P(\varphi) = I \setminus A(\varphi) \, , \ \nonumber  &amp;&amp;  \Psi(\varphi) = { \psi \in H : \langle h</em>i, \psi \rangle<em>H = b</em>i \, , \ i \in A(\varphi) } \ , \ \nonumber  &amp;&amp;  g<em>{ij} = \langle h</em>i , h<em>j \rangle</em>H \, , \quad 1 \le i,j \le S \ . \end{eqnarray} Feasible part of set <span>$\Psi(\varphi), \, \varphi \in \Phi$</span> is a face of set <span>$\Phi$</span> containing <span>$\varphi$</span>. If <span>$A(\varphi)$</span> is empty (it is possible when <span>$L =0$</span>) then <span>$\Psi(\varphi) = H$</span>. </p><p>In accordance with optimality conditions [4, 5] the solution of the problem (1), (4), (5) can be represented as:  \begin{eqnarray} \sigma &amp;=&amp; \sum <em>{i=1} ^L \mu _i h</em>i + \sum <em>{i=L+1} ^{M+L} (\mu _i - \mu _{i+M}) h</em>i \ , \ \nonumber    &amp;&amp; \mu<em>i \le 0 \ , \quad \mu</em>{i+M} \le 0 \ , \quad  L+1 \le i \le L+M \, , \ \nonumber \
   &amp;&amp; \mu<em>i (\langle h</em>i , \sigma \rangle<em>H - b</em>i ) = 0 \, ,   \quad  L+1 \le i \le N \, , \
   &amp;&amp; \mu<em>i \, \mu</em>{i+M} = 0 \ , \qquad \qquad \ \ \  L+1 \le i \le S \, . \end{eqnarray} Here complementary slackness conditions (9) means that <span>$\mu_k = 0$</span> for <span>$k \in P(\sigma)$</span> and the relations (10) reflect the fact that any pair of constraints (5) with indices <span>$i$</span> and <span>$i + M$</span> cannot be simultaneously active on the solution.Thereby there are at most <span>$S$</span> non-trivial coefficients <span>$\mu_i$</span> in formula (8) and actual dimension of the problem (1), (4), (5) is <span>$S$</span>.</p><p>Let <span>$\hat\sigma$</span> be the normal solution of the system (4), then it can be written as \begin{eqnarray}     \hat\sigma =  \sum <em>{i=1} ^L \mu _i h</em>i \ , \end{eqnarray} where coefficients <span>$\mu_i$</span> are determined from the system of linear equations with symmetric positive definite Gram matrix <span>$\{g_{ij}\}$</span> of the linear independent elements <span>$h_i$</span>: \begin{eqnarray}     \sum <em>{j=1} ^L g</em>{ij} \mu <em>j = b</em>i  \ , \quad 1 \le i \le L \ . \end{eqnarray} If <span>$L = 0$</span> then there are no constraints (4) and <span>$\hat\sigma = 0$</span>. If <span>$\hat\sigma$</span> satisfies constraints (5), that is, the inequalities \begin{eqnarray<em>}     {\langle h<em>i , \hat\sigma \rangle}</em>H \le b_i \  ,  \qquad L+1 \le i \le N \ , \end{eqnarray</em>} which can be written like this: \begin{eqnarray}     \sum <em>{j=1} ^L g</em>{ij} \mu <em>j \le b</em>i  \ ,    \qquad L+1 \le i \le N \ , \end{eqnarray} then <span>$\hat\sigma$</span> is a solution to the original problem (1), (4), (5), i.e. <span>$\sigma = \hat\sigma$</span>.</p><p>Consider nontrivial case when <span>$\hat\sigma$</span> does not satisfy constraints (5). In this case <span>$\sigma$</span> belongs to the boundary of the set <span>$\Phi$</span> and is the projection of zero element of space <span>$H$</span> onto the set <span>$\Psi (\sigma)$</span>. The projection <span>$\vartheta$</span> of zero element of space <span>$H$</span> onto the set <span>$\Psi (\varphi)$</span> can be presented as \begin{eqnarray}   \vartheta  =  \sum <em>{i \in A(\varphi)} \mu _i h</em>i \ , \end{eqnarray} here factors <span>$\mu_i$</span> are defined from the system of linear equations with symmetric positive definite matrix \begin{eqnarray}     \sum <em>{j \in A(\varphi)} g</em>{ij} \mu <em>j = b</em>i  \ ,    \qquad i \in A(\varphi) \ , \end{eqnarray} If factors <span>$\mu_i$</span>, <span>$i \in I_2 \cap A(\varphi)$</span> corresponding to the inequality constraints are nonpositive, then we can set <span>$\mu_i = 0$</span> for <span>$i \in P(\varphi)$</span> and get all conditions (8)—(10) satisfied thereby <span>$\vartheta  = \sigma$</span> is a solution of the problem under consideration. The following algorithm is based on this remark.  Let&#39;s describe its iteration.</p><p>Let <span>$\sigma^ k$</span> be a feasible point of the system (4),(5): \begin{eqnarray}   \sigma^k = \sum <em>{i = 1}^N \mu</em>i^k h<em>i \ , \end{eqnarray} In this presentation there are at most <span>$S$</span> non-zero multipliers ``\mu</em>i^k<span>$. We denote$</span>\vartheta^k<span>$as a projection of zero element of space$</span>H<span>$onto the set$</span>\Psi (\vartheta^k)<span>$,$</span>A<em>k = A(\sigma^k)<span>$and$</span>P</em>k = P(\sigma^k) = I \setminus A<em>k<span>$. Then$</span>\vartheta^k`` can be resented as \begin{eqnarray}  &amp;&amp; \vartheta^k = \sum _{i \in A</em>k} \lambda<em>i^k h</em>i = \sum <em>{i = 1}^N \lambda</em>i^k h<em>i \ , \quad \lambda</em>i^k = 0  \, , \  \forall i \in P<em>k \ , \
&amp;&amp;  \sum _{j \in A</em>k} g<em>{ij} \lambda</em>j^k = b<em>i  \, ,  \quad i \in A</em>k \ . \end{eqnarray} There are two possible cases: the point <span>$\vartheta^k$</span> is feasible or it is not feasible. In the first case we check the optimality conditions, namely: if <span>$\lambda_i^k \le 0, \  \forall i \in I_2$</span> then  <span>$\vartheta^k$</span> is the solution of the problem. If the optimality conditions are not satisfied then we set <span>$\sigma^{k+1} = \vartheta^k$</span>, find an index <span>$i \in A_k$</span> such that <span>$\lambda_i^k &gt; 0$</span> and remove it from <span>$A_k$</span>. In the second case <span>$\sigma^{k+1}$</span> will be defined as a feasible point of the ray <span>$\vartheta (t)$</span> \begin{eqnarray}   \vartheta (t) = \sigma^k + t (\vartheta^k - \sigma^k)  \ , \end{eqnarray}                                                                                                                                           such that it is closest to the <span>$\vartheta^k$</span>. Denote <span>$t^k_{min}$</span> the corresponding value of <span>$t$</span> and <span>$i_k \in P_k$</span> — a related number of the violated constraint. This index <span>$i_k$</span> will be added to <span>$A_k$</span> forming <span>$A_{k+1}$</span>. Thereby all <span>$\sigma^k$</span> are feasible points, that is, the minimization process proceeds within the feasible region and value of <span>$\| \sigma^k \|_H$</span> is not increasing. The minimization process is finite because of linear independence of the constraints, it eliminates the possibility of the algorithm cycling. The feasibility of the <span>$\vartheta^k$</span> can be checked as follows. Introduce the values <span>${e_i^k}, \,  k \in P_k$</span>: \begin{eqnarray}  e<em>i^k = \langle h</em>i , \vartheta^k - \sigma^k \rangle<em>H =  \sum _{j=1}^N g</em>{ij}(\lambda<em>j^k - \mu _j^k) \ ,  \quad i \in P</em>k \ , \end{eqnarray} If <span>${e_i^k} &gt; 0$</span> then constraint with number <span>$i$</span> can be violated at the transition from <span>$\sigma^k$</span> to point <span>$\vartheta^k$</span>, in a case when <span>${e_i^k} &lt; 0$</span> the constraint with number <span>$i + M$</span> can be violated. For all <span>$i \in P_k$</span> compute values \begin{eqnarray}   t<em>i^k = \cases{            \frac {b</em>i - \langle h<em>i , \sigma^k \rangle</em>H}{e<em>i^k} \ ,                           \quad e</em>i^k &gt; 0  \cr \cr            \frac {-b<em>{i+M} - \langle h</em>{i+M} , \sigma^k \rangle<em>H}{e</em>i^k} \ ,                           \quad e<em>i^k &lt; 0  \cr \cr            1 \ , \quad e</em>i^k = 0 \cr                } \ , \end{eqnarray} where \begin{eqnarray<em>} &amp;&amp; \langle h<em>i , \sigma^k \rangle</em>H =   \sum <em>{j=1}^N g</em>{ij} \mu <em>j^k \ , \
  &amp;&amp; \langle h</em>{i+M} , \sigma^k \rangle<em>H =                  \sum _{j=1}^N g</em>{i+M,j} \mu <em>j^k \ , \quad i \in P</em>k \ , \end{eqnarray</em>} here all <span>$t_i^k \ge 0$</span>. Now the maximum feasible step <span>$t^k_{min}$</span> is computed as \begin{eqnarray}     t^k<em>{min} = \min</em>{i \in P<em>k} { t</em>i^k } <br/>\end{eqnarray} and <span>$\vartheta^k$</span> is feasible if and only if <span>$t^k_{min} \ge 1$</span> (see 19).</p><p>Thereby the algorithm&#39;s iteration consist of seven steps: Initialization. Let <span>$\sigma^0$</span> be a feasible point of the system (4),(5) and <span>$\mu_i^0$</span>  are corresponding multipliers (16). Compute multipliers <span>$\lambda_j^k, \ i \in A_k$</span> as solution of the system (18). If <span>$| A_k | = S$</span> then go to Step 6. Compute <span>$t_i^k, \ \forall i \in P_k$</span>. Find <span>$t^k_{min}$</span> and the corresponding index <span>$i_k$</span>.  If <span>$t^k_{min} &lt; 1$</span> (projection <span>$\vartheta^k$</span> is not feasible) then set \begin{eqnarray<em>}   &amp;&amp; \mu<em>i^{k+1} = \mu</em>i^k + t^k<em>{min} (\lambda</em>i^k - \mu<em>i^k) \ , \quad i \in A</em>k \ , \ &amp;&amp; A<em>{k+1} = A</em>k \cup { i_k } \ , \end{eqnarray</em>} and return to Step 1. (projection <span>$\vartheta^k$</span> is feasible). If exists index <span>$i_p, \ i_p \in A_k$</span> such that <span>$\lambda_{i_p}^k &gt; 0$</span> then set \begin{eqnarray<em>}  &amp;&amp; A<em>{k+1} = A</em>k \setminus { i<em>p } \ , \ &amp;&amp; \mu</em>i^{k+1} = \lambda<em>i^k  \ , \quad  i \in A</em>{k+1} \ , \end{eqnarray</em>} and return to Step 1. Set <span>$\sigma = \vartheta^k$</span>. Stop. The algorithm starts from an initial feasible point of the system (4),(5). Such point <span>$\sigma^0$</span> can be defined as the normal solution of the system \begin{eqnarray}  {\langle h<em>i , \varphi \rangle}</em>H = u<em>i \, \quad 1 \le i \le S \ , \end{eqnarray} and can be presented as \begin{eqnarray}   \sigma^0 = \sum _{i = 1}^S \mu</em>i^0 h<em>i \ , \end{eqnarray} where multipliers ``\mu</em>i^0<span>$are defined from the system \begin{eqnarray}   \sum _{j=1} ^S g_{ij} \mu _j^0  = u_i  \ ,    \qquad 1 \le i \le  S \ . \end{eqnarray} The algorithm described here implements a variant of the active set method [2] with the simplest form of the minimized functional (1). It can also be treated as a variant of the conjugate gradient method [7] and allows to solve the considered problem by a finite number of operations. The conjugate gradient method in this case is reduced into the problem of finding the projection$</span>\vartheta^ k<span>$, that is, into a solution of system (18). Infinite dimensionality of the space$</span>H<span>$for this algorithm is irrelevant. The most computationally costly part of the algorithm is calculation of projections$</span>\vartheta^k<span>$by solving systems (18). Matrices of all systems (18) are positive definite (by virtue of linear independence of elements$</span>h_i``) and it is convenient to use Cholesky decomposition to factorize them. At every step of the algorithm a constraint is added to or removed from the current active set and the system (18) matrix gets modified by the corresponding row and symmetric column addition or deletion. It is possible to get Cholesky factor of the modified matrix without computing the full matrix factorization (see previous post), it allows greatly reduce the total volume of computations.</p><p>This algorithm can be also applied in a case when instead of modular constraints (3) there are one-sided inequality constraints \begin{eqnarray}     {\langle h<em>{i+L} , \varphi \rangle}</em>H \le u<em>{i+L} \, , \quad 1 \le i \le M \, , \end{eqnarray} for that it is enough to set  \begin{eqnarray}   b</em>{i+L} = u<em>{i+L} \ , \quad  b</em>{i+S} = -\infty \, , \quad 1 \le i \le M \, . \end{eqnarray} in (6).</p><p>To be continued on the next post.</p><p>References</p><p>[1] A. Balakrishnan, Applied Functional Analysis, Springer-Verlag, New York, 1976. [2]  P. Gill, W. Murray, M. Wright, Practical Optimization, Academic Press, London, 1981. [3] V. Gorbunov, The method of reduction of unstable computational problems (Metody reduktsii neustoichivykh vychislitel&#39;nkh zadach), Ilim, 1984. [4] A. Ioffe, V. Tikhomirov, Theory of extremal problems, North-Holland, Amsterdam, 1979. [5] P.-J. Laurent, Approximation et optimization, Paris, 1972. [6] I. Kohanovsky, Data approximation using multidimensional normal splines. Unpublished manuscript. 1996. [7] B. Pshenichnyi, Yu. Danilin, Numerical methods in extremal problems,  Mir Publishers, Moscow, 1978.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 8 October 2020 14:31">Thursday 8 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
